## 相关概念

### Seata相关术语

- TC(transaction coordinator): 事务协调器,维护全局事务的运行状态. 对应的是seata服务
- TM(transaction manager): 控制全局事务的边界,负责开启一个全局事务
- RM(resource manager): 控制分支事务,负责分支注册,状态汇报,与TC交谈,接受TC的提交或回滚操作

### 事务执行流程

1. TM通知TC开启一个分布式事务,TC生成一个XID.
2. XID经由调用链传递下去
3. RM将本地事务注册为XID对应的分支事务
4. TM通知TC进行全局回滚或提交
5. TC驱动XID对应的所有分支事务进行回滚或提交.

## 事务模式主要有四种: AT/TCC/SAGA/XA事务模式.

### AT 模式

AT 模式是一种无侵入的分布式事务解决方案。在 AT 模式下，用户只需关注自己的"业务 SQL"，用户的 "业务 SQL" 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作.

#### 整体机制

- 一阶段: 业务数据和回滚日志记录在同一个本地事务中提交,释放本地锁和连接资源.
  > 分支(本地)事务执行. 将本地事务作为分布式事务的一个分支.
  > 
  > 在此阶段,seata会拦截业务sql,解析sql语义,查询需要更新的sql,在更新前将查询的数据保存为`before image`,在业务数据更新后,再保存一份为`after image`,最后生成锁. 这些操作在一个数据库事务内完成,保证了原子性.
- 二阶段: 
  - 提交异步化,非常快速的完成.
  - 回滚通过一阶段的`before image`进行还原业务数据。
  - **还原前需要验证脏写，对比当前业务数据和`after image`是否一致，一致说明没有脏写，不一致说明有脏写，需要转人工处理。**
  > 分支事务提交或者回滚. 阶段二完成的是全局事务的提交或者回滚,当全局事务中所有分支事务都执行成功之后,TM会向TC发起全局事务提交的通知,TC收到之后,再通知RM进行提交. 如果某个分支失败了,TM会通知TC进行全局回滚,TC通知RM进行回滚.
  > 
  > 此阶段会会根据第一阶段的执行情况决定是提交还是回滚. 等到一阶段未抛异常,全局事务的发起方会向服务端申请提交这个事务,服务端根据xid查询出该全局事务后加锁并关闭这个全局事务.为了防止有分支事务继续注册到这个分布式事务上,将其状态从begin修改为committing. 接着服务端判断全局事务是否为AT模式,是的话则进行异步提交,因为AT模式下此阶段数据已经修改,服务端只需要修改事务状态为AsyncCommitting,然后会有一个定时线程池去db或file中查询待提交的全局事务日志进行提交,提交成功会释放全局锁并且删除事务日志.


### TCC(Try-Confirm-Cancel)模式

TCC 模式需要用户根据自己的业务场景实现 Try、Confirm 和 Cancel 三个操作；事务发起方在一阶段执行 Try 方式，在二阶段提交执行 Confirm 方法，二阶段回滚执行 Cancel 方法。**对业务有入侵性。用户需要关注如何把业务拆分成二阶段,实现TCC的三个方法。**

- Try：资源的检测和预留；
- Confirm：执行的业务操作提交；要求 Try 成功 Confirm 一定要能成功；
- Cancel：预留资源释放；

#### 允许空回滚

**Cancel 接口设计时需要允许空回滚。在 Try 接口因为丢包时没有收到，事务管理器会触发回滚，这时会触发 Cancel 接口，这时 Cancel 执行时发现没有对应的事务 xid 或主键时，需要返回回滚成功。让事务服务管理器认为已回滚，否则会不断重试，而 Cancel 又没有对应的业务数据可以进行回滚。**

#### 防悬挂控制
**Cancel 比 Try 接口先执行，出现的原因是 Try 由于网络拥堵而超时，事务管理器生成回滚，触发 Cancel 接口，而最终又收到了 Try 接口调用，但是 Cancel 比 Try 先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的 Try 接口不应该执行，否则会产生数据不一致，所以我们在 Cancel 空回滚返回成功之前先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口先检查这条事务xid或业务主键如果已经标记为回滚成功过，则不执行 Try 的业务操作。**

### SAGA模式

长事务的解决方案，在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。
分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。

Saga 模式适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁、长流程情况下可以保证性能。

事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，可以使用 Saga 模式。

Saga模式的优势是：
一阶段提交本地数据库事务，无锁，高性能；
参与者可以采用事务驱动异步执行，高吞吐；
补偿服务即正向服务的“反向”，易于理解，易于实现；

缺点：Saga 模式由于一阶段已经提交本地数据库事务，且没有进行“预留”动作，所以不能保证隔离性。

### XA模式

在 Seata 定义的分布式事务框架内，利用事务资源（数据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一种 事务模式。执行阶段：可回滚：业务 SQL 操作放在 XA 分支中进行，由资源对 XA 协议的支持来保证 可回滚 持久化：XA 分支完成后，执行 XA prepare，同样，由资源对 XA 协议的支持来保证 持久化（即，之后任何意外都不会造成无法回滚的情况） 完成阶段：分支提交：执行 XA 分支的 commit 分支回滚：执行 XA 分支的 rollback。
XA 模式在一阶段执行完毕之后不会释放锁，也就是不会提交事务，基于数据库 XA 协议的实现方式，二阶段执行回滚或提交，利用了数据库本身的事务特性。

**优点是实现了强一致性，同时保证隔离性。**

**缺点是性能差，并发低，因为一阶段和二阶段执行过程中锁不释放**






