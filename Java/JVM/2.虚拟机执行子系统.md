### Class 类型信息

Class 文件只有两种数据类型,**无符号数和表**

> 无符号数: 基本的数据类型, u1/u2/u4/u8 分别代表 1 个字节/4 个字节/8 个字节的无符号数. 用来描述数字/索引引用/数量值/字符串
>
> 表: 表是由多个无符号数或者其他表作为数据项组成的复杂数据类型.

#### Class 文件结构

1. 魔数(0xcafebabe) 占四个字节

2. 次版本号(major_version 占两个字节)和主版本号(minor_version 占两个字节)

3. 常量池

   **常量池主要存放两大类常量: 字面量和符号引用. 字面量一般是字符串或者常量值等. 符号引用属于编译原理方面的概念.主要包括以下几类常量:**

   - 被模块导出或开发的包
   - 类和接口的全限定名
   - 字段的名称和描述符
   - 方法的名称和描述符
   - 方法句柄和方法类型
   - 动态调用点和动态常量

4. 访问标记(access_flags):用于识别类或者接口层次的访问信息 占两个字节

   ```
   ACC_PUBLIC
   ACC_FINAL
   ACC_SUPER  # 是否允许使用invokespecial字节码指令的新语义,jdk1.0.2之后编译出的类都有这个标识
   ACC_INTERFACE
   ACC_ABSTRACT
   ACC_SYNTHETIC
   ACC_ANNOTATION
   ACC_ENUM
   ACC_MODULE
   ```

5. 类索引/父类索引/接口索引集合

6. 字段表集合: 用于描述类或接口声明的变量

   字段表结构主要包含以下几个
   |类型 | 名称 | 数量|
   | :-:|:-:|:-: |
   | u2 | access_flags | 1 |
   | u2 | name_index | 1 |
   | u2 | descriptor_index | 1 |
   | u2 | attributes_count | 1 |
   | attribute_info | attributes | attributes_count |

7. 方法表集合: 结构和字段表集合一样.

   ```
   ACC_SYNCHRONIZED
   ```

8. 属性表集合(attribute_info):

Java 虚拟机会调用"类加载器"子系统把类加载到内存中

#### 字节码指令

1. 加载和存储指令: 用于将数据在栈帧中的局部变量表和操作数栈之间来回传输
   - 将一个局部变量加载到操作数栈 : <t>load\_<n>
   - 将一个数值从操作数栈存储到局部变量表 <t>store\_<n>
   - 将一个常量加载到操作数栈
2. 运算指令 : 用于将操作数栈上的两个值进行指定运算,并把结果重新存入操作数栈顶.

   - 加(add)/减(sub)/乘(mul)/除(div)/取余(rem)/求反(neg)/位移(shl)

3. 类型转换指令: 将两种不同的数值类型进行转换,用于代码中的显式转换类型操作

4. 对象创建和访问指令
   - 创建类示例 new / 创建数组示例 (newarray/anewarray/multianewarray)
   - 访问类字段 getfield/putfield/getstatic/putstatic
   - 把一个数组元素加载到操作数栈的指令: baload/caload/salod/iaload/faload/daload/aaload
   - 将一个操作数栈的值存储到数组元素的指令: bastore/castore/sastore/iastore/fastore/dastore/aastore
   - 获取数组长度指令: arraylength
   - 检查类示例类型的指令: instanceof/checkcast
5. 操作数栈管理指令
   - 将操作数栈栈顶元素移除: pop/pop2
   - 将栈顶两个元素交换位置: swap
   - 复制栈顶一个或两个数值并将复制的值重新压入栈顶: dup/dup2/dup_x1/dup2_x1
6. 控制转移指令: 可以让 jvm 虚拟机有条件或无条件的从指定位置指令的下一条指令继续执行程序.
   - 条件分支 ifeq/iflt/ifle/ifne/ifgt/ifge/ifnull/ifnonnull/if_icmpeq/...
   - 复合条件分支: tableswitch/lookupswitch
   - 无条件分支: goto/goto_w/jsr/jsr_w/ret
7. 方法调回和返回指令

   1. invokevirtual 指令: 调用实例方法
   2. invokeinterface 指令: 调用接口方法
   3. invokespecial: 调用私有方法/父类方法
   4. invokestatic: 调用类静态方法
   5. invokedynamic: 用于在运行时动态解析出调用点限定符所引用的方法.

8. 异常处理指令:

   1. 同步指令: **java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步. 这两种同步结构都是使用管程(Monitor,俗称锁)实现的.**

### 类加载

#### 类加载时机

类加载主要分为`加载`>`验证`>`准备`>`解析`>`初始化`>`使用`>`卸载` 几个步骤. 前四个步骤属于**加载->连接**过程,jvm 虚拟机规范没有强制规定,交给虚拟机的具体实现自由把握.而初始化步骤严格规定只有以下六种情况会立即对类进行初始化操作

- 遇到`new`/`getstatic`/`putstatic`/`invokestatic`四个指令时,如果没有对类进行初始化操作会先初始化
- 使用反射操作对操作类时.
- 初始化类时,父类没有进行初始化,先初始化父类.
- 虚拟机启动,先初始化 main 方法所在类
- 使用 jdk7 加入的动态语言支持时, 在 java.lang.invoke.MethodHandle 对象生成的指令为 getstatic/putstatic/invokestatic/newInvokestatic 四种类型的方法句柄,方法所在类没有初始化,先进行初始化操作
- jdk8 新加入的接口 default 方法,有接口的实现类进行初始化操作,会先初始化父类

以上是主动引用,会触发类的初始化操作,被动引用不会触发类的初始化操作. 被动引用有以下几种

- 通过子类使用父类的静态字段
- 定义类的数组
- 使用类静态常量的情况不会触发

#### 类加载过程

1. **加载**,由类加载器执行.该步骤将查找字节码,并从这些字节码创建一个 class 对象.

   > 加载分几个步骤
   >
   > 1. 根据类的全限定名找到对应的 class 文件
   > 2. 读取 class 文件,把静态存储结构转化为方法区转为运行时数据结构
   > 3. 在方法区创建一个 class 对象,作为数据访问的入口

   **加载阶段和连接阶段的部分动作是交叉进行的,加载阶段尚未完成,连接部分阶段已经开始. 开始顺序仍然保持固定的先后顺序.**

2. **连接**,在连接阶段将验证类中的字节码,为 static 字段分配存储空间,如果需要的话,解析这个类创建的对其他类的所有引用

   > 连接分三个阶段
   >
   > - 验证: 验证 class 类是否符合 jvm 虚拟机规范,以及是否对 jvm 有危害
   > - 准备: 为静态变量分配内存.赋初始值
   > - **解析: 将常量池内的符号引用转为直接引用\*\***
   >   - 符号引用指通过一组符号(字面量)引用定义目标.和内存布局无关.
   >   - 直接引用是直接指向目标的指针/相对偏移量/或者能直接定位的句柄.

3. **初始化,执行类构造器(\<clinit\>)的过程**,如果该类具有超类,则先初始化超类,执行 static 初始化器和 static 初始化块.

   **遇到 new/getstatic/putstatic/invokestatic 指令时才会执行初始化方法**

   > 执行类构造器 clinit 方法, javac 编译器自动生成的所有类变量赋值和静态语句块的合集. 合集的顺序是根据源文件出现的顺序决定的. 静态语句块内只能访问在此之前的静态变量.

直到第一次引用一个 static 方法(构造器是隐式的 static)或者非常量(包含 static final)的 static 字段,才会进行初始化.

#### 类加载器

虚拟机角度主要分为两种类加载器. Bootstrap Class Loader 和其他类加载器. BootstrapClassLoader 类加载器负责加载<JAVA_HOME>/lib 目录下的类. 由 C++语言实现(仅限 HotSpot 虚拟机).是虚拟机自身的一部分. 其他类加载器都是 java 语言实现,都是继承自 java.lang.ClassLoader 抽象类.

从开发者的角度看分以下几种

- 启动加载器(Bootstrap Class Loader) : 负责加载<java_home>/lib 目录下的类库. 开发者无法获取启动加载器的引用.

- 扩展类加载器,主要实现是 sun.misc.Launcher$ExtClassLoader 类,主要加载<java_home>/lib/ext 包或者 java.ext.dirs 环境变量的类库.

- 引用程序类加载器(Application Class Loader),主要实现在 sun.misc.Launcher$AppClassLoader 类.负责加载用户(UserClassPath)路径下的类库. 由于 ClassLoader.getSystemClassLoader()方法返回的是此加载器,所以也被称为**系统加载器**.
- 用户自定义类加载器: 自己实现的类加载器

双亲委派模型要求除了引导类加载器之外都要有自己的父类加载器.

**双亲委派模型工作流程: 某个类加载器受到加载类的请求时,先交给父类加载器去加载. 如果父类加载器反馈无法加载,再自己进行加载. 父子关系通过组合实现,不是继承. ** 好处是 java 类和他的类加载器具备了一种优先级的层次关系. 可以避免重复加载和核心 api 被篡改.

因为只有在全限定名和类加载器完全相等的情况下,才会被认定为一个类. 避免核心 api 被篡改. 避免类的重复加载.

### 虚拟机字节码执行引擎

字节码在执行时最小的执行单元是栈帧. 一个方法在虚拟机中代表一个栈帧. 栈帧中主要包含元素有以下四种:

- **操作数栈**

  是一个先入后出的栈. 最大长度在编译阶段已经确定.

- **局部变量表**

  存放方法参数和运行时定义的局部变量. 实例方法第一个参数是当前对象.最大长度在编译阶段已经确定.

- **动态连接**

  字节码中没有保存对象在内存中的地址, 在方法中有对常量池中符号引用的引用,符号引用转为直接引用称为动态连接. 在类加载或者第一次使用时,有一个静态链接.

  每个 class 文件的常量池中有大量的符号引用. 字节码的方法调用指令就以常量池里指向方法的符号引用作为参数. 这些符号引用一部分会在类加载阶段或者第一次使用的时候被转为直接引用.这种称为静态连接. 另一部分在每一次运行期间转化为直接引用,这种称为动态连接.

- 方法返回地址

  只有两种方式退出方法. 1: 遇到方法返回的字节码指令. 2: 执行中遇到了异常.

#### 方法调用

方法调用字节码 **invoke**

- invokestatic: 调用静态方法. 静态分派
- invokespecial: 调用私有实例方法和构造器和父类实例方法. 静态分派
- invokevirtual: 调用非私有实例方法. 属于动态分派
- invokeinterface: 调用接口方法. 动态分派
- invokedynmaic: 调用动态方法

> 方法调用并不等于方法被执行.方法调用的唯一任务是找到被调用方法的版本(即调用哪个方法).
>
> Class 文件中并没有保存运行时的方法内存布局中的入口地址. 存储的都是符号引用. 这个特性给 java 带来了更强大的动态扩展能力.

1. **解析调用**: 在编译的时候已经确认调用的方法. 在类加载的时候把符号引用转为直接引用.
2. **分派调用**
   1. 静态分派. 编译时或者加载时确认的方法
   2. 动态分派
   3. 多分派


