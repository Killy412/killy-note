# JVM

![image-20200420092646642](../img/image-20200420092646642.png)

> 整个JVM内存空间分为堆,栈,方法区(永久代)
>
> - <font color="red">**堆:是Java虚拟机管理的内存中最大的一块,堆是被所有线程共享的区域,虚拟机创建时启动,存放的是对象的实例**</font>,堆可分为**年轻代**和**老年代**,年轻代可分为**Eden**区和两个**survivor**区,新生代和老年代的比例是1:2,默认的,Eden:from:to=8:1:1 
>
>   - 年轻代
>     - Eden
>     - From Survivor
>     - To Survivor
>   - 老年代
>
> - <font color="red">**方法区(永久代):存储虚拟机加载的类信息,常量,静态变量,所有线程共享的区域,是一片连续的堆空间,**</font>配置永久代大小 **-XX:MaxPermSize** 默认是64M,64位JVM是85M,方法区相关配置如下
>
>   - -XX:PermSize=64MB            最小尺寸，初始分配
>   - -XX:MaxPermSize=256MB  最大允许分配尺寸，按需分配
>   - XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled 设置垃圾不回收
>   - 默认大小
>   - -server选项下默认MaxPermSize为64m
>   - -client选项下默认MaxPermSize为32m
>
> - <font color="red">**栈:线程私有,生命周期和线程相同,创建线程时会创建一个Java虚拟机栈**</font>
>
>   虚拟机执行Java程序的时候,每个方法都会创建一个栈帧,栈帧存放在虚拟机栈中,通过压栈出栈的方式进行调用
>
>   - 栈帧又分为:局部变量表,操作数栈,动态链接,方法出口等 **Java8中基本类型的变量存储在栈中的局部变量表中,引用型的变量只存储引用地址**
>   - 本地方法栈和虚拟机栈作用类似,区别是虚拟机栈为虚拟机执行Java方法服务,本地方法栈为虚拟机使用的navicat方法服务
>   - 程序计数器(PC Register),记录当前线程执行程序的位置,改变计数器的值确定下一条执行的指令,线程私有
>
>   

- **堆栈区别**

>堆是所有线程共享的区域,存放实例化的对象/数组.
>栈是线程私有的,每创建一个线程会新建一个线程栈,存储局部变量和对象的引用变量.
>方法区是所有线程共享的一块空间,主要存放加载的类信息/常量/静态变量
>
>**栈:** 在函数中定义的一些基本类型的变量和对象的引用变量都在栈内存中分配.当一块代码中定义一个变量时,Java就在栈中为这个变量分配内存空间,超出变量的作用域后,Java会自动释放为该变量分配的内存空间,该内存空间可以立即被其他所用.
>
>**堆:** 用来存放new出来的对象和数组.在堆中分配的内存,由Java虚拟机的自动垃圾回收器来处理.

- jvm内存参数配置
  - -Xms设置堆的最小空间大小。
  - -Xmx设置堆的最大空间大小。
  - -Xmn:设置年轻代大小
  - -XX:NewSize设置新生代最小空间大小。
  - -XX:MaxNewSize设置新生代最大空间大小。
  - -XX:PermSize设置永久代最小空间大小。
  - -XX:MaxPermSize设置永久代最大空间大小。
  - -Xss设置每个线程的堆栈大小
  - -XX:+UseParallelGC:选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集。
  - -XX:ParallelGCThreads=20:配置并行收集器的线程数,即:同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。


- **典型JVM参数配置参考:** 

>- java-Xmx3550m-Xms3550m-Xmn2g-Xss128k
>- -XX:ParallelGCThreads=20
>- -XX:+UseConcMarkSweepGC-XX:+UseParNewGC

- -Xmx3550m:设置JVM最大可用内存为3550M。
- -Xms3550m:设置JVM促使内存为3550m。此值可以设置与-Xmx相同,以避免每次垃圾回收完成后JVM重新分配内存。
- -Xmn2g:设置年轻代大小为2G。整个堆大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64m,所以增大年轻代后,将会减小年老代大小。此值对系统性能影响较大,官方推荐配置为整个堆的3/8。
- -Xss128k:设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右.

- **查看堆的默认值**

```shell
java -XX:+PrintFlagsFinal -version | grep HeapSize
```

### 数据存储

那么，程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据：

1. **寄存器**（Registers）最快的存储区域，位于 CPU 内部 [^2](https://lingcoder.gitee.io/onjava8/#/大多数微处理器芯片都有额外的高速缓冲存储器，但这是按照传统存储器而不是寄存器。)。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++ 允许开发者向编译器建议寄存器的分配）。
2. **栈内存**（Stack）存在于常规内存 RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java 系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据（如对象引用），但 Java 对象本身的数据却是保存在堆内存的。
3. **堆内存**（Heap）这是一种通用的内存池（也在 RAM 区域），所有 Java 对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用 `new` 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用 Java 在栈内存上创建对象，就像在 C++ 中那样的话）。随着时间的推移，Java 的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。
4. **常量存储**（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM （只读存储器，Read Only Memory）中 [^3](https://lingcoder.gitee.io/onjava8/#/一个例子是字符串常量池。所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中。)。
5. **非 RAM 存储**（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象。Java 为轻量级持久化提供了支持。而诸如 JDBC 和 Hibernate 这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。

##### 数据类型范围
| 基本类型 |  大小   |  最小值   |     最大值     | 包装类型  |
| :------: | :-----: | :-------: | :------------: | :-------: |
| boolean  |    —    |     —     |       —        |  Boolean  |
|   char   | 16 bits | Unicode 0 | Unicode 216 -1 | Character |
|   byte   | 8 bits  |   -128    |      +127      |   Byte    |
|  short   | 16 bits | -2<sup>15</sup> |    +2<sup>15</sup> -1    |   Short   |
|   int    | 32 bits |   -2<sup>31</sup>   |    +<sup>231</sup>-1    |  Integer  |
|   long   | 64 bits |   - 2<sup>63</sup>   |    + 2<sup>63</sup> -1    |   Long    |
|  float   | 32 bits |  IEEE754  |    IEEE754     |   Float   |
|  double  | 64 bits |  IEEE754  |    IEEE754     |  Double   |
|   void   |    —    |     —     |       —        |   Void    |



### Class类型信息

Java虚拟机会调用"类加载器"子系统把类加载到内存中

> 类加载器首先检查类的Class是否已经加载,如果没有加载,默认类加载器会根据类名查找.class文件.
> 这个类的字节码被加载之后,jvm会对其进行验证,确保没有损坏.
> 一旦某个类的Class被加载到内存之后,可以用来创建这个类的对象.

##### 类加载步骤

1. **加载**,由类加载器执行.该步骤将查找字节码,并从这些字节码创建一个class对象.
2. **链接**,在链接阶段将验证类中的字节码,为static字段分配存储空间,如果需要的话,解析这个类创建的对其他类的所有引用
3. **初始化**,如果该类具有超类,则先初始化超类,执行static初始化器和static初始化块.

直到第一次引用一个static方法(构造器是隐士的static)或者非常量(包含static final)的static字段,才会进行初始化.