### volatile

使共享变量成为线程可见

>每个线程有自己单独的工作内存,保存当前线程使用的共享变量副本,在使用完之后把变量同步到主内存中.
>而volatile变量不会被线程缓存,始终从主存中读取
>
>##### MESI(缓存一致性协议)
>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
>
>##### 嗅探
>
>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
>##### 嗅探的缺点
>由于volatile的MESI缓存一致性问题,需要不断从主内存嗅探和cas不断循环,无效交互会导致总线带宽达到峰值  
>
>##### 总结
>1. 只能用于属性,不会被指令重排序
>2. 提供线程可见性,不会被线程缓存,每次使用都从主存中读取
>3. 可以在单例双重检查中实现可见性和禁止指令重排,保证安全性
>4. 缺点是不能保证原子性

### CAS(compare and swap)
>乐观锁的一种实现方式

