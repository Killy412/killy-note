# 设计模式

| 范围\目的 |                 创建型模式                  |                          结构型模式                          |                          行为型模式                          |
| :-------: | :-----------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  类模式   |                  工厂方法                   |                         (类）适配器                          |                       模板方法、解释器                       |
| 对象模式  | 单例 <br />原型 <br />抽象工厂 <br />建造者 | 代理 (对象）<br />适配器 <br />桥接 <br />装饰 <br/>外观 <br />享元 <br/>组合 | 策略 <br />命令<br />职责链 <br />状态 <br />观察者 <br />中介者 <br />迭代器 <br />访问者 <br />备忘录 |


## 创建型模式

> 实现对象的实例化,提高创建对象代码的灵活性和重用性

### 单例模式

静态内部类懒汉式单例模式

```java
public class Signleton{
    private static class SignletonHonder{
        public static Signleton sign=new Signleton();
    }
    
    private Signleton{}
    
    public static Signleton getInstance(){
        return SignletonHonder.sign;
    }
}
```

1. **静态内部类方式如何实现懒加载**

   Java类的加载过程包括:加载-验证-准备-解析-初始化.初始化方法执行类的clint方法(clint=class+initalize),包括为类的静态变量赋初始值和执行静态块的代码.但不会立即加载内部类,内部类在使用时才会加载.  当访问一个类的静态字段时,如果该类没有初始化,会立即去初始化.所以实现了懒加载.

2. **静态内部类怎么保证线程安全**

   虚拟机在加载类的clint方法时,考虑了线程安全,会保证在clint在多线程中被正确的加载/同步.即使多线程同时初始化一个类,一次也只有一个线程可以执行clint方法,其他线程需要阻塞等待,实现了线程安全.

   **一般的建议:** <font color="red">对于构建不复杂,加载完会立即使用的单例对象,使用饿汉式.对于构建时间较长,并不是所有使用此类都用用到的单例对象,使用懒汉式.</font>

### 工厂模式

> 定义一个用于创建产品的接口，由子类决定生产什么产品。

##### 简单工厂
##### 工厂方法
##### 抽象工厂
> 在面向对象编程中,继承是一个基本概念,与多态共同构成了类的父子继承关系.
>
> 工厂模式用于实现逻辑的封装,通过公共的接口实现对象的实例化服务,添加新类时只需要做少量的代码修改.

### 建造者模式

> 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。

### 原型模式

> 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。

### 对象池模式




## 行为型模式

> 行为型模式关注对象交互，通信和控制流。

### 责任链模式

> 把请求从链中的一个对象传到下一个对象,直到请求被响应为止.通过这种方式去除对象之间的耦合.

### 命令模式

> 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。

### 解释器模式

> 提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

### 迭代器模式

> 提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

### 观察者模式

> 多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为.

### 中介者模式

> 定义一个中介对象来简化原有对象之间的交互关系,降低系统中对象间的耦合度,使原有对象之间不必相互了解.

### 备忘录模式

> 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它.

### 状态模式

> 允许一个对象在其内部状态发生改变时改变其行为能力.

### 策略模式

> 定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户.

### 模板方法模式

> 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

### 空对象模式
### 访问者模式

> 在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。




## 结构型模式

### 适配器模式

> 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

- 类的适配器模式：比如一个类有一个方法method1，但是客户端使用的时候还需要一个method2方法，那就可以将method1和method2方法写进接口中，然后新建一个适配器类继承原来的类并实现这个接口。
- 对象的适配器模式：与类适配器相比，不需再继承source类，而是将source的对象传过去。
- 接口的适配器模式

### [代理模式](./%E4%BB%A3%E7%90%86.md)

> 为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。

- 静态代理,通过接口编码实现
- 动态代理,利用jdkApi,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象/实现接口的类型),默认实现接口的全部方法
- cglib代理,属于动态代理

### 装饰器模式

> 动态的给对象增加一些职责，即增加其额外的功能。

一般来说实现对象增强的三种方法
- 继承父类,字类扩展
- 装饰器模式,使用包装的方法增强对象
- 代理模式

### 桥接模式

> 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

### 组合模式

> 将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

### 外观模式

> 为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。

### 享元模式

> 运用共享技术来有效地支持大量细粒度对象的复用。