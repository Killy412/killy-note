## 线性数据结构

### 数组

数据是一种很常见的数据结构.由相同的元素组成,使用的是一块连续的内存空间. 提供随机访问,并且数量有限.

### 链表

链表也是一种常见的线性数据结构. 但是并不会按照线性的顺序存储,使用的是不连续的内存空间. 插入和删除操作的复杂度都是`O(1)`,访问的复杂度是`O(n)`. 链表结构没有数组必须直到长度的缺点,可以充分的利用内存空间,但是会占用更多的内存空间.

#### 常见链表分类

- 单链表

  每个节点有一个后继节点,指向下一个节点,最后一个节点的后继节点指向null.

- 双向链表

  每个节点有两个指针,分别是前驱节点和后继节点.第一个节点的前驱节点为null. 最后一个节点的后继节点为null

- 循环链表

  最后一个节点的后继节点指向第一个节点,形成循环.

- 双向循环链表

  第一个节点的前驱节点是最后一个节点. 最后一个节点的后继节点是第一个节点.

#### 链表练习题

- 单链表反转
- 链表中环的检测
- 两个有序链表合并
- 删除链表倒数第N个节点
- 求链表中间节点

### 栈(stack)

只允许在有序的线性数据集合的一端进行新增(push)和删除(pop)操作. 具有后进先出的特性(last in first out).**push和pop操作都发生在栈顶.** 常用一维数组和链表实现,数组实现的叫顺序栈,链表实现的叫链式栈.

### 队列

队列是**先进先出(first in first out)**的线性数据结构. 通常使用数组或链表实现. 队列只能在队头出队,在队尾入队.常分为顺序队列(数组实现)和链式队列(链表实现).

- 单队列
- 循环队列

## 非线性数据结构

### 图

### 树

#### 二叉树

#### 堆

堆的定义: 堆是一个完全二叉树. 任意节点的任意子节点都大于等于(小于等于)当前节点.

## 算法

### 排序算法

#### 冒泡排序

#### 插入排序

把数组分为两个区间,已排序和未排序区间,每次从未排序区间取出第一个数,与已排序区间进行比较,插入到合适的位置.

```java
static int[] insertionSort(int[] arr) {
    final int l = arr.length;
    if(l<2){
        return arr;
    }
    for (int i = 1; i < l; i++) {
        final int val = arr[i];
        int j = i - 1;
        for (; j >= 0; j--) {
            if (arr[j] > val) {
                arr[j + 1] = arr[j];
            } else {
                break;
            }
        }
        arr[j + 1] = val;
    }
    return arr;
}
```



#### 选择排序

把数组分为两个区间,已排序和未排序区间,每次从未排序区间取出一个最小值,放在已排序区间中.

```java
static int[] selectionSort(int[] arr) {
    final int length = arr.length;
    if (length <= 1) {
        return arr;
    }
    for (int i = 0; i < length; i++) {
        int minIndex = i;
        for (int j = i + 1; j < length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int tmp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = tmp;
    }
    return arr;
}
```

#### 归并排序

对数组分割成前后两个部分,进行排序,然后合并. 递归此操作.

#### 快速排序

//todo 重点



## 散列表

使用散列函数把元素的key映射为下标,然后将数据存储到下表对应的位置中. 查找元素时,按照key的散列函数计算出下标,找到对应下标的元素. 散列表的重点是**解决散列冲突和散列函数的设计**

### 散列冲突

不同的key值经过散列函数所得到的下标是一样的. 一般使用两种解法: 开放寻址法和链表法.

#### 1.开放寻址法

- 线性探测: 存储元素时,如果已经对应位置已经不为空,则继续向后寻找,寻找到空的位置再存储.  查找元素时,计算对应的下标,然后判断key是否相同,不同的话,继续向后探测,探测到第一个为空的位置,还没找到,则判定没有此元素.
- 二次探测: 线性探测每次探测的步长是1, 二次探测每次探测的步长是`hash(key)+0,hash(key)+1^2,hash(key)+2^2...`
- 双重散列: 使用多个散列函数,如果第一次经过散列计算之后的下标位置已经被占用,则 继续进行第二个散列函数的计算.直到找到空闲的位置.

**当数据量和装载因子较小的时候,适合使用开放寻址法. 这也是Java的ThreadLocalMap中使用开放寻址法的原因.**

#### 2.链表法

每个槽对应一个链表. 散列冲突时,插入到链表中.

**基于链表的散列冲突解决方法适合处理数据量较大或者内存较大的情况,更加灵活,支持更多的优化策略.**

### HASH 算法的应用

1. 安全加密
2. 唯一标识
3. 数据校验
4. 散列函数
5. 负载均衡: 可以解决会话粘滞问题
6. 数据分片
7. 分布式存储
