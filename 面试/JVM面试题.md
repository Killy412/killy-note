## jvm内存

### java 中堆和栈分别是什么?

> 堆是所有变量存储的地方,所有线程共享的区域.
>
> 栈是线程私有的,创建一个线程的时候,会创建对应的线程栈

### java7 和 java8 在内存布局有什么变化

> java7 的永久代是存放在堆内存区域中的. 在 java8 中把永久代改成了元数据空间(Meta space),并单独占一块区域, 元数据空间不会占用堆内存空间.
>
> 方法区保存一些类静态变量,类信息等数据

### 堆的结构包含什么

- edan 区
- 两个 Survol 区
- 一个老年代

### 栈的结构包含什么

- 局部变量表
- 操作数栈
- 栈帧
- 动态连接

### 常用命令行工具

- javac 编译工具
- javap 查看字节码工具
- jps 查看运行 java 程序
- jinfo 查看指定 java 程序信息
- **jstack 查看指定 java 程序栈信息**
- **jmap 查看指定 java 程序内存信息/生成内存快照**
- jhat java 堆栈分析工具
- **jstat 查看指定 java 程序状态**
- jconsole

## 字节码

### 字节码

> 类加载的本质把一个类的二进制表示加载到 jvm 中.
> 某个 jvm 方法需要进行调用,需要用到某个类时,调用类加载子系统加载类.会使用 ClassLoader 加载某个类.

### 什么是双亲委派模型,有什么好处

> 双亲委派模型就是类加载器需要加载某个类的时候,会先给父加载器去加载,如果父类加载不了,才由当前加载器去加载.
>
> 好处是,保护核心类的安全.不会被恶意类破坏.

### 类加载的过程是怎么样的

> 

### 类加载器类型

> 主要有三种
>
> - BootstrapClassLoader: 初始类加载器 .加载jvm运行时需要的核心类库, lib目录下的类库
> - ExtClassLoader: 扩展类加载器. 主要加载 lib/ext文件目录下或者``java.ext.dirs`指向的类库
> - AppClassLoader: 应用程序类加载器. 加载classpath参数中的类库. 也叫系统加载器. 通过`ClassLoader.getSystemClassLoader()`获取此加载器的引用
> - 自定义类加载器

### instanceof 如何判断两个实例是否相同

> 类加载器和类的全限定名都相同

## GC

### 什么是 GC

> GC就是垃圾回收. java程序无法自己操作内存,使用gc进行自动垃圾回收

### 描述一下 GC 的过程

> 堆内存包含几个空间: 年轻代,老年代. 年轻代又分为edan区和两个交换区. 
>
> 新对象创建出来在edan区. 经历过一次young gc之后,如果依然存在,会升级到交换区. 如果在交换区存活的年龄到一个指定值时(每经历一次ygc,年龄会增加1)/或者当交换区相同年龄的对象大于交换区一半时,会被升级到老年代.
>
> 新对象创建时会在edan区申请内存空间,如果内存不够,会进行ygc,进行ygc??

### GC roots 包含的哪些对象

> 1. Thread对象
> 2. 类变量/类信息
> 3. 局部变量

### 如何判断一个对象是否存活

> 使用可达性分析算法. 使用GC roots去扫描引用的对象,如果没有被扫描到,就可以判断对象可以回收.

### 什么是分代 GC,分为哪些代

> 年轻代
>
> 老年代
>
> 永久代

### 什么是强/软/弱/虚引用

> 强引用就是使用new的对象,永远不会被回收
>
> 软引用的对象会在被回收之前再进行一次gc. 如果gc之后内存依然不够用,会被回收掉. 会存活到下次gc之前. SoftReference
>
> 弱引用是只要执行gc就会被回收. 实现类是WeakReference
>
> 虚引用实际没什么用. 就是在jvm会收到被回收消息.

### 什么是 stop the world

> jvm执行gc时,会停止所有线程的工作去扫描gc roots对象.

比较安全,会产生很多延迟.

### 听说过哪些 GC 算法

> 扫描-清除: 会产生很多小的内存块. 没有连续内存空间.
>
> 扫描-复制: 把内存分成容量相同的两块,一次只用一块内存,扫描之后把存活的对象复制到另一块内存中,清理之前那块内存.
>
> 扫描-整理: 扫描gc roots对象, 把无用对象回收. 然后把所有存活对象左移整理.

### 听说过哪些GC 回收器

> - serializ 单线程回收器
> - serializ old 老年代的垃圾回收器
> - parell new 多线程回收器
> - parell old 老年代的多线程回收器
> - parell sev..
> - cms :  ...
> - g1 : 分块垃圾回收. 把内存分为很多块,每个块都可以当作edan区/old区, 垃圾回收的时候,会根据内存块可回收的内存大小进行排序,会把回收价值最大的内存块回收掉.

### 听说过哪些调优参数

> - Xms  初始堆内存大小
> - Xmx 堆内存最大值
> - Xmn 栈内存大小
> - UseCMS
> - ...

## 多线程

### 线程安全是什么

> 线程安全就是线程执行之后的结果符合预期. 

- java 中如何保证线程安全
  - 使用不可变对象
  - 锁
  - 无锁容器
- 什么是死锁

### 线程池

- 为什么使用线程池
- 常见线程池和使用场景/参数
- 主要类`Exectors` `ThreadPoolExector`

### 线程的生命周期,状态

> `Thread.State`
> NEW(新创建出来的,未启动的)->
>
> RUNNING(可运行的线程,可能正在等待操作系统的其他资源)->
>
> BLOCKED-> 等待锁释放的状态.  如果线程a持有m方法的锁,线程b想进入方法必须先持有锁,线程b处于这种状态.
>
> WAITING->  等待线程的状态. 调用以下方法会处于线程处在waiting状态(Object.wait()/Thread.join()/LockSupport.park())
>
> TIMED_WAITING-> 有指定时间等待的等待状态. 调用以下方法会使线程处在这个状态(Thread.sleep()/Object.wait(long)/Thread.join(long)/LockSupport.parkUnit(unit)/LockSupport.parkNanos(long))
>
> TERMINATED  线程终止

### volatile 是干嘛的

jmm java 线程模型
可见性
每个线程都有自己的工作内存,会把主内存的变量复制到工作内存中. 如果有改变

> 修饰在成员属性上. java线程模型分为主内存和工作内存.  正常每个线程有一个自己的工作内存, 会先把主内存的变量拷贝到工作内存中,然后直接操作工作内存. 使用volatile修饰的变量是读写都操作主内存.

### 什么是 java 线程模型

每个线程可以被分配到一个 cpu 上,有一个工作内存,
除了局部变量,所有变量都是 java 所有线程共享的

### ThreadLocal 原理

ThreadLocal 里的值放在 Thread 里,

> 

### synchronized 和 lock 优缺点

synchronized 是一个关键字,比较简单,不需要手动释放锁.只能有一个线程持有锁.
lock 是 jdk 层面,有丰富的 api. 需要手动释放锁.比较灵活.

### synchronized 锁升级/锁粗化

> 

### 无锁 cas 原理/常用 juc 工具类

- countDownLatch
- CyclicBaiier
- S
-

## 数据库
### 事物和隔离等级

事物四大特性
acid: 原子性/一致性/隔离性/持久性

隔离等级:事物并发情况

- 读未提交(read uncommitted): 产生脏读
- 读已经提交(read committed): 产生不可重复读
- 可重复读(repeatable read): 产生幻读 mysql 默认隔离等级
- 事物串行(Serializable):

#### 事物的幂等性

> 重复提交相同事物是否会产生相同的结果

### 乐观锁/悲观锁

> 乐观锁就是在修改数据的时候加上一个预期值的条件
>
> 悲观锁就是在拿到数据的时候上锁,顺序访问

### 数据库基本数据结构

- B+树
- hash

索引如何排布:

### 索引优化

- 最左匹配: 符合索引在有多个列建立索引的时候,如果条件中包含第一个列则会用到索引.
- 如何判断 sql 查询是否使用了索引: `explain`关键词 type/key
- 如何进行索引优化: 根据业务来

### 如何避免 sql 注入

Mybatis Orm 框架

## Redis

### Redis 为什么这么快

全内存操作
因为 redis 瓶颈不在网络 io 等,所以是单线程.避免多线程的线程切换开销.

> 数据都存放在内存中. 单线程,因为redis瓶颈不在网络/磁盘io等,内存的操作速度很快,单线程省去了多线程的线程上下文切换开销.

### 为什么单线程就会快

> ?

### Redis6.0 多线程了解吗

> 多加了个线程组去处理连接/释放连接等操作,核心线程依然是单线程处理数据.

### redis 数据结构

string 字符串
hash
list 列表,按照插入顺序排序
set 无序集合
zset 有序集合,每个值有个对应的分数