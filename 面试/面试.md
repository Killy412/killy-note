# 面试题

### JVM

#### java7 和 java8 在内存布局有什么变化

> java7 的永久代是存放在堆内存区域中的. 在 java8 中把永久代改成了元数据空间(Meta space),并单独占一块区域, 元数据空间不会占用堆内存空间.
>
> 方法区保存一些类静态变量,类信息等数据

#### 栈的结构包含什么

- 操作数栈
- 局部变量表
- 栈帧
- 动态链接

#### **JVM内存分配原理,垃圾回收原理**

   > JVM内存主要分为栈/堆/方法区,堆是jvm内存中最大的一块区域.栈是线程私有的,创建一个线程的时候会创建一个线程栈.

   > 引用计数回收算法.
   >
   > 可达性分析算法: 通过一个根节点 Gc roots 作为起始节点集,然后根据引用关系向下搜索,搜索过程所走的路径称为引用链,如果某个对象到gc roots没有任何引用链相连,就说明此对象不可用

#### 类加载过程

   1. 加载

      > 加载阶段有三个步骤
      >
      > 1. 通过一个类的全限定名获取定义此类的二进制字节流
      > 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
      > 3. 在内存中生成一个代表这个类的Class对象,作为方法区这个类的各种数据访问入口

   2. 验证: 确保类中的字节流包含的信息符合jvm虚拟机规范的要求,保证不会危害jvm的安全

   3. 准备: 为类中定义的静态变量分配内存并设置类变量初始值的阶段

   4. 解析: jvm将常量池内的符号引用替换为直接引用的过程

   5. 初始化: 执行类构造器的过程

      > 是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的

   > ##### 初始化类触发场景
   >
   > 1. 遇到new getstatic putstatic invokestatic时,如果没有初始化类,会触发初始化类. 几种场景: 使用new创建对象,读取或设置静态变量时,调用静态方法的时候.
   > 2. 对类型进行反射调用的时候
   > 3. 初始化类的时候如果没有初始化父类,会先初始化父类
   > 4. 如果有接口的实现类发生了初始化,接口发生在这之前

#### 类加载器

> 主要有三种
>
> - BootstrapClassLoader: 初始类加载器 .加载jvm运行时需要的核心类库, lib目录下的类库
> - ExtClassLoader: 扩展类加载器. 主要加载 lib/ext文件目录下或者``java.ext.dirs`指向的类库
> - AppClassLoader: 应用程序类加载器. 加载classpath参数中的类库. 也叫系统加载器. 通过`ClassLoader.getSystemClassLoader()`获取此加载器的引用
> - 自定义类加载器

#### 什么是双亲委派模型

> 双亲委派模型就是类加载器需要加载某个类的时候,会先给父加载器去加载,如果父类加载不了,才由当前加载器去加载.
>
> 好处是,保护核心类的安全.不会被恶意类破坏.

#### gc的流程

   > gc流程
   >
   > 1. 新创建的对象实例都存放在edan中,会先判断edan剩余内存够不够用,足够的话直接分配内存
   > 2. 不够的话,执行minor gc,执行完继续判断够不够,足够分配
   > 3. 不够的话,去survivor区看内存够不够,会继续判断老年代剩余内存是否足够
   > 4. 老年代不够会执行full gc

   > 执行minor gc流程
   >
   > 1. 先判断老年代剩余大小是否足够,足够直接晋升
   > 2. 不够会判断是否开启分配担保的配置
   > 3. 开启的话,先判断老年代剩余空间是否大于历次晋升的平均值,大于的话执行minor gc,不大于的话执行full gc
   > 4. 未开启执行 full gc

##### 简单gc过程

新对象创建出来在edan区. 经历过一次young gc之后,如果依然存在,会升级到交换区. 如果在交换区存活的年龄到一个指定值时(每经历一次ygc,年龄会增加1)/或者当交换区相同年龄的对象大于交换区一半时,会被升级到老年代.

#### gc root对象有哪些

- Thread对象
- 类变量
- 局部变量

#### 线上Java项目出现故障,排查思路

> Java线上故障一般几个方面,
>
> - CPU
>
>   ```shell
>   # 使用ps命令查找占用内存比较高的进程的pid
>   ps -aux|grep java
>   # 使用top命令查找占用内存较高的线程
>   top -H -p <pid>
>   ```
>
> - 内存
>
>   > 内存问题主要是堆/GC/堆外内存问题.
>
> - 磁盘
>
> - GC问题
>
> - 网络

#### 虚拟机性能监控工具

```shell
# jps 虚拟机进程状况工具
jps -l

# jstat 虚拟机统计信息监视工具
jstat [option vmid]

# jmap Java内存映像工具
jmap [option] vmid

# jstack Java堆栈跟踪工具
jstack [option] vmid

# jinfo java配置信息工具
jinfo [option] pid


# jhat 虚拟机堆转储快照分析工具

# 可视化多合一故障处理工具
jvisualvm
```

### 并发

#### <font color="red">**ConcurrentHashMap/HashMap/HashTable底层结构区别**</font>

   > HashMap是线程不安全的.其他两个是线程安全的.底层结构是数组+链表
   >
   > hashMap原理: hashmap是基于hash,底层是数组+链表的结构. 第一次put的时候先判断table是否为空,如果是空,调用resize()方法进行初始化.并且计算出临界值. table不为空,再根据key的hash值计算出对应table的下标,为空直接创建一个node.不为空再继续判断key的hash值/key的值是否相同,相同直接替换,判断得到对应桶的类型,为tree添加tree,不为tree添加到链表中.
   >
   > concurrentHashMap原理:1.7之前采用分段锁的数组,核心类是segment,实现了retranntlock. 1.8采用了cas+sync
   >
   > hashtable也是线程安全的,但是所有方法都加上synchronized

#### HashMap1.7和1.8实现有什么区别



#### list线程安全类有哪些

#### **多线程创建几种方式,线程池原理,经常使用的线程池的类**

   > 通过线程池/new 创建.
   >
   > 提交任务到线程池,如果池中线程数不足核心线程数量,会新建线程,如果没有空闲线程,会放在等待队列中,等待队列已满的话,会继续创建新线程,知道达到线程池最大大小,如果继续提交任务,会触发拒绝策略.
   >
   > 经常使用的线程池的类有:CacheThreadPool/FixedThreadPool/SingleThreadExecutor/ScheduledThreadPool

##### LinkedBlockingQueue和ArrayBlockingQueue区别

linkedblockqueue是基于链表实现,是无界的,如果积压任务过多,对gc有影响.arrayblockingqueue是基于数组的,长度有限,实现使用一把锁.

#### **synchronized,volatile关键字作用和区别**

   > synchronized是实现线程安全的一种方式,悲观锁的一种实现,可以放在方法上,或者锁对象.
   >
   > volatile是保证变量的可见性以及防止重排序.

#### juc中synchronized实现阻塞队列

#### **CAS底层实现**

   > CAS全称是 compare and swap,比较替换,乐观锁的一种实现.
   >
   > CAS有三个参数, V:内存中的值,A预期值,B修改后的值,修改的时候比较一下V和A是否相等,相等的话修改成功,不等的话,循环修改,直到成功,步骤如下:
   >
   > 1. 读取内存值为一个临时变量
   > 2. 对旧值的临时变量进行操作
   > 3. 判断旧值的临时变量是否等于旧值,如果不等,则不修改,循环继续执行,相等,修改成功

#### CAS如何保证原子性的

cmpxchg cpu原子指令

### Spring

#### **Spring Aop底层实现的原理/动态代理**

> 原理: 用代理类包裹切面,织入spring管理的bean中,
>
> 动态代理实现
>
> spring aop动态代理实现方式有两种,jdk动态代理和cglib动态代理
>
> - jdk动态代理通过反射来生成目标代理接口的匿名实现类.
> - cglib动态代理:如果目标类没有实现接口,springaop会使用cglib动态代理目标类.可以在运行时生成某个类的子类,通过继承的方式做的动态代理,如果某个类时final,无法使用cglib动态代理

#### **spring事物的实现**

> 事物实现的几种方式
>
> 1. 编程式事物,需要在代码中调用beginTransaction,commit,rollback等事物相关的方法
> 2. 基于TransactionProxyFactoryBean的声明式事物
> 3. 基于注解@Transaction的声明式事物
>
> 使用aop(面向切面编程)实现声明式事物

##### rollback不指定的情况下哪些异常不会回滚

unchecked exception 未检查异常会回滚. 继承自runtimexception

checked exception不会回滚. 检查异常必须被捕获或者抛出. 继承自exception

#### spring bean的生命周期

   > 1. 实例化
   > 2. 填充属性
   > 3. 调用BeanNameAware的setBeanName方法
   > 4. 调用BeanFactoryAware的setBeanFactory方法
   > 5. 调用applicationContextAware的setApplicationContext方法
   > 6. 调用beanPostProcesser的预初始化方法
   > 7. 调用InitializingBean的afterPropertiesSet方法
   > 8. 调用自定义初始化方法
   > 9. 调用beanPostProcesser的初始化后方法
   >
   > ---使用---------------------
   >
   > 10. 调用disposablebean
   > 11. 调用destory销毁方法

#### 注解原理

 反射注解的工作原理

 1. 首先,在方法上标记注解,并且可以为注解的属性赋值
 2. 在进行反射使用的时候,虚拟机将所有生命周期在RUNTIME的注解取出来放在一个map中,并创建一个AnnotationInvocationHandler实例,把这个map传给他
  3. 最后,虚拟机采用jdk动态代理机制生成目标注解的代理类,并初始化好处理器
         

### MyBatis

#### 一级缓存和二级缓存有什么区别

- 一级缓存是session级别,只要执行update操作时或者关闭session时就会清空缓存.
- 二级缓存是application级别,是按照namespace来存储的,执行update时会清空缓存.

### mysql

#### 底层存储结构

#### 索引类型有什么,b+tree和hash索引的区别

> 常用索引有: 主键索引 唯一索引  复合索引 外键索引 全文索引
>
> hash索引查询起来比较快,因为直接存的hash值,一次就可以查询到.不支持范围查询,不支持排序
>
> B+Tree索引支持范围查询/匹配最左前缀,支持排序

#### mysql有几种存储引擎

- innodb: 常用的存储引擎,支持事物,支持行锁/表锁
- myisam: 不支持事物,查询新增数据比较快,只支持表锁

#### mysql调优经验

#### 隔离级别

 - 未提交读 readuncommitted,产生脏读,读取未提交事物的数据
 - 提交读 readcommitted 提交读,不可重复读,一个事物中,多次读取数据可能不一致
 - 可重复读 repeatable read 可重复读,解决脏读的问题,一个事物中多次读取数据的结果是一致的,可能产生幻读
 - 可串行化 serializable 串行化 执行效率最低,所有事物串行

#### 簇集索引和非簇集索引区别

#### mysql哪些机制防止幻读

多版本并发控制(mvcc) 解决幻读问题

#### mysql读写分离模式

### 网络

##### TCP和UDP的区别

都是传输层的协议
TCP: 面向连接,可靠的,基于字节流的传输通讯协议,仅支持单点连接 发送数据前需要进行三次握手进行连接,断开连接时需要四次握手断连.
UDP: 面向无连接,支持一对多,多对多,传输不可靠,传输实时数据报文比较高效

### 微服务

#### cap

- 一致性(Consistency)  数据一致性
- 可用性(Availability) : 某个服务瘫痪不影响整个分布式服务正常运行
- 分区容错性(Partition Tolerance) : 分布式系统中服务之间出现了网络故障,整个分布式系统仍然保持可用性和一致性

#### 分布式事物tcc和at和xa分别是什么

#### 服务降级的实现方式

    > 通过feign调用其他服务方式时,可以直接写个调用的实现类,在调用其他微服务的接口注解中,指定该类
    > 服务熔断就是指调用某个服务失败到一定次数之后,熔断打开,避免大量无用请求.服务保持在开路状态之后一段时间,切换到半开路状态,会判断下一次请求的情况,成功的话,断路器切回到闭路状态.否则回到断路状态.

### docker

- DockerFile文件结构



##### docker底层用什么实现应用隔离

使用linux的cgroup和namespace这两项技术实现应用隔离



### BIO和NIO的区别

